#!/usr/bin/env python3
"""
Chicago Data Integration Script for DignityAI
Fixed version without sys arguments and annotations
"""

import os
import json
import logging
import requests
import pandas as pd
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
import time
from collections import defaultdict

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class ChicagoDataFetcher:
    """Fetch and process Chicago Open Data without annotations"""
    
    def __init__(self):
        self.base_url = "https://data.cityofchicago.org/resource/"
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'DignityAI-Research/1.0',
            'Accept': 'application/json'
        })
    
    def get_police_data(self, limit: int = 1000) -> Dict:
        """Fetch recent police incident data with location analysis"""
        try:
            logger.info("🚔 Fetching Chicago police data...")
            
            url = f"{self.base_url}crimes.json"
            params = {
                "$limit": limit,
                "$order": "date DESC",
                "$where": "date > '2024-01-01T00:00:00.000'",
                "$select": "date,block,primary_type,description,arrest,domestic,beat,district,ward,community_area,latitude,longitude"
            }
            
            response = self.session.get(url, params=params, timeout=45)
            response.raise_for_status()
            data = response.json()
            
            # Analyze by location
            location_analysis = self._analyze_by_location(data)
            
            return {
                "source": "Chicago Police Incidents - Location Analysis",
                "total_incidents": len(data),
                "recent_date": data[0].get('date', 'Unknown') if data else None,
                "location_breakdown": location_analysis,
                "sample_data": data[:3] if data else []
            }
            
        except Exception as e:
            logger.error(f"Error fetching police data: {e}")
            return {"source": "Chicago Police Incidents", "error": str(e)}
    
    def get_311_data(self, limit: int = 1000) -> Dict:
        """Fetch 311 service requests with location analysis"""
        try:
            logger.info("📞 Fetching Chicago 311 data...")
            
            url = f"{self.base_url}v6vf-nfxy.json"
            params = {
                "$limit": limit,
                "$order": "creation_date DESC",
                "$where": "creation_date > '2024-01-01T00:00:00.000'",
                "$select": "creation_date,status,completion_date,service_request_number,type_of_service_request,street_address,zip_code,ward,police_district,community_area"
            }
            
            response = self.session.get(url, params=params, timeout=45)
            response.raise_for_status()
            data = response.json()
            
            # Analyze by zip code
            zip_analysis = self._analyze_by_zip_code(data)
            service_analysis = self._analyze_311_types(data)
            
            return {
                "source": "Chicago 311 Service Requests - Location Analysis",
                "total_requests": len(data),
                "recent_date": data[0].get('creation_date', 'Unknown') if data else None,
                "zip_code_breakdown": zip_analysis,
                "service_type_analysis": service_analysis
            }
            
        except Exception as e:
            logger.error(f"Error fetching 311 data: {e}")
            return {"source": "Chicago 311 Service Requests", "error": str(e)}
    
    def get_budget_data(self) -> Dict:
        """Fetch Chicago budget information"""
        try:
            logger.info("💰 Fetching Chicago budget data...")
            
            url = f"{self.base_url}xbkb-dz87.json"
            params = {
                "$limit": 1500,
                "$select": "fund,department,appropriation_authority,appropriation_account,appropriation_account_desc,budget_year,budget_amount_thousands"
            }
            
            response = self.session.get(url, params=params, timeout=45)
            response.raise_for_status()
            data = response.json()
            
            # Analyze budget by department
            dept_analysis = self._analyze_budget_by_department(data)
            
            return {
                "source": "Chicago Budget Data - Enhanced Analysis",
                "total_entries": len(data),
                "department_breakdown": dept_analysis,
                "sample_allocations": data[:3] if data else []
            }
            
        except Exception as e:
            logger.error(f"Error fetching budget data: {e}")
            return {"source": "Chicago Budget Data", "error": str(e)}
    
    def _analyze_by_location(self, data: List[Dict]) -> Dict:
        """Analyze data by geographic location"""
        analysis = {
            "by_beat": defaultdict(int),
            "by_district": defaultdict(int),
            "by_ward": defaultdict(int),
            "by_community_area": defaultdict(int)
        }
        
        for item in data:
            if item.get('beat'):
                analysis["by_beat"][item['beat']] += 1
            if item.get('district'):
                analysis["by_district"][item['district']] += 1
            if item.get('ward'):
                analysis["by_ward"][item['ward']] += 1
            if item.get('community_area'):
                analysis["by_community_area"][item['community_area']] += 1
        
        # Convert to regular dict and sort by frequency
        return {
            "by_beat": dict(sorted(analysis["by_beat"].items(), key=lambda x: x[1], reverse=True)[:10]),
            "by_district": dict(sorted(analysis["by_district"].items(), key=lambda x: x[1], reverse=True)),
            "by_ward": dict(sorted(analysis["by_ward"].items(), key=lambda x: x[1], reverse=True)[:10]),
            "by_community_area": dict(sorted(analysis["by_community_area"].items(), key=lambda x: x[1], reverse=True)[:10])
        }
    
    def _analyze_by_zip_code(self, data: List[Dict]) -> Dict:
        """Analyze 311 requests by zip code"""
        zip_analysis = defaultdict(lambda: {
            'total_requests': 0,
            'service_types': defaultdict(int),
            'completion_rate': 0,
            'completed': 0
        })
        
        for item in data:
            zip_code = item.get('zip_code')
            if zip_code:
                zip_analysis[zip_code]['total_requests'] += 1
                
                service_type = item.get('type_of_service_request', 'Unknown')
                zip_analysis[zip_code]['service_types'][service_type] += 1
                
                if item.get('status', '').upper() in ['COMPLETED', 'CLOSED']:
                    zip_analysis[zip_code]['completed'] += 1
        
        # Calculate completion rates
        for zip_code in zip_analysis:
            total = zip_analysis[zip_code]['total_requests']
            completed = zip_analysis[zip_code]['completed']
            zip_analysis[zip_code]['completion_rate'] = (completed / total * 100) if total > 0 else 0
        
        # Sort by total requests
        sorted_zips = sorted(zip_analysis.items(), 
                            key=lambda x: x[1]['total_requests'], 
                            reverse=True)[:15]
        
        return dict(sorted_zips)
    
    def _analyze_311_types(self, data: List[Dict]) -> Dict:
        """Analyze common 311 request types"""
        type_counts = defaultdict(int)
        for item in data:
            req_type = item.get('type_of_service_request', 'Unknown')
            type_counts[req_type] += 1
        
        sorted_types = sorted(type_counts.items(), key=lambda x: x[1], reverse=True)
        return dict(sorted_types[:10])
    
    def _analyze_budget_by_department(self, data: List[Dict]) -> Dict:
        """Analyze budget allocations by department"""
        dept_budgets = defaultdict(float)
        
        for item in data:
            dept = item.get('department', 'Unknown')
            amount_str = item.get('budget_amount_thousands', '0')
            
            try:
                amount = float(amount_str) if amount_str else 0
                dept_budgets[dept] += amount
            except (ValueError, TypeError):
                continue
        
        # Sort by budget amount
        sorted_depts = sorted(dept_budgets.items(), key=lambda x: x[1], reverse=True)
        return dict(sorted_depts[:15])
    
    def get_comprehensive_chicago_data(self) -> Dict:
        """Gather comprehensive Chicago data for analysis"""
        logger.info("📊 Gathering comprehensive Chicago data...")
        
        context = {
            "timestamp": datetime.now().isoformat(),
            "data_sources": {}
        }
        
        try:
            # Police data
            context["data_sources"]["police"] = self.get_police_data()
            time.sleep(2)
            
            # 311 data
            context["data_sources"]["service_requests"] = self.get_311_data()
            time.sleep(2)
            
            # Budget data
            context["data_sources"]["budget"] = self.get_budget_data()
            
            logger.info("✅ Chicago data gathering complete")
            
        except Exception as e:
            logger.error(f"Error gathering Chicago data: {e}")
            context["error"] = str(e)
        
        return context

def save_chicago_data(data: Dict, filename: str = None) -> str:
    """Save Chicago data to JSON file"""
    if not filename:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"chicago_data_{timestamp}.json"
    
    try:
        # Create output directory
        os.makedirs('data', exist_ok=True)
        filepath = os.path.join('data', filename)
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        
        logger.info(f"✅ Chicago data saved to: {filepath}")
        return filepath
        
    except Exception as e:
        logger.error(f"Error saving Chicago data: {e}")
        return ""

def main():
    """Main execution function"""
    try:
        logger.info("🚀 Starting Chicago data collection...")
        
        # Initialize data fetcher
        fetcher = ChicagoDataFetcher()
        
        # Gather comprehensive data
        chicago_data = fetcher.get_comprehensive_chicago_data()
        
        # Save data
        saved_file = save_chicago_data(chicago_data)
        
        # Print summary
        print("\n" + "="*60)
        print("📊 CHICAGO DATA COLLECTION COMPLETE")
        print("="*60)
        
        data_sources = chicago_data.get('data_sources', {})
        
        if 'police' in data_sources:
            police = data_sources['police']
            print(f"🚔 Police: {police.get('total_incidents', 0)} incidents")
        
        if 'service_requests' in data_sources:
            sr = data_sources['service_requests']
            print(f"📞 311 Requests: {sr.get('total_requests', 0)} requests")
        
        if 'budget' in data_sources:
            budget = data_sources['budget']
            print(f"💰 Budget: {budget.get('total_entries', 0)} line items")
        
        print(f"💾 Data saved to: {saved_file}")
        print("="*60)
        
        logger.info("✅ Chicago data collection completed successfully")
        
    except Exception as e:
        logger.error(f"❌ Error in main execution: {e}")
        raise

if __name__ == "__main__":
    main()
